#!/bin/bash

# ARG_OPTIONAL_BOOLEAN([base],[b],[Run base module],[on])
# ARG_OPTIONAL_BOOLEAN([selfupdate],[],[Update set-me-up],[])
# ARG_OPTIONAL_BOOLEAN([provision],[p],[Provision given modules],[off])
# ARG_OPTIONAL_REPEATED([modules],[m],[Modules to provision])
# ARG_OPTIONAL_ACTION([lsrc],[],[List files that will be symlinked via 'rcm' into your home directory],[list_symlinks])
# ARG_OPTIONAL_ACTION([rcup],[],[Symlink files via 'rcm' into your home directory],[symlink])
# ARG_OPTIONAL_ACTION([rcdn],[],[Remove files that were symlinked via 'rcup'],[remove_symlinks])
# ARG_HELP([set-me-up installer])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


# # When called, the process ends.
# Args:
# 	$1: The exit message (print to stderr)
# 	$2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to $1)
# Example:
# 	test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}


# Function that evaluates whether a value passed to it begins by a character
# that is a short option of an argument the script knows about.
# This is required in order to support getopts-like short options grouping.
begins_with_short_option()
{
	local first_option all_short_options='bpmh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_base="on"
_arg_selfupdate="off"
_arg_provision="off"
_arg_modules=()

SMU_HOME_DIR=${SMU_HOME_DIR:-"${HOME}/set-me-up"}
readonly module_path="${SMU_HOME_DIR}/.dotfiles/modules"


list_symlinks() {
	# List files that will be symlinked via 'rcup' using set-me-up/.dotifles/rcrc.
	export RCRC="${SMU_HOME_DIR}/.dotfiles/rcrc" && lsrc -v -d "${SMU_HOME_DIR}/.dotfiles"
}

symlink() {
	# Remove broken symlinks in '$HOME' directory.
	find -L $HOME -name . -o -type d -prune -o -type l -exec rm {} +

	# Symlink files listed within set-me-up/.dotifles/rcrc to the '$HOME' directory.
    export RCRC="${SMU_HOME_DIR}/.dotfiles/rcrc" && rcup -v -f -d "${SMU_HOME_DIR}/.dotfiles"
}

remove_symlinks() {
	# Remove files that were symlinked via 'rcup'.
	export RCRC="${SMU_HOME_DIR}/.dotfiles/rcrc" && rcdn -v -d "${SMU_HOME_DIR}/.dotfiles"
}

create_boot_disk() {
	# Creates a MacOS Catalina boot disk.
	"${module_path}"/create_boot_disk/create_boot_disk.sh
}


# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help()
{
	printf '%s\n' "set-me-up installer"
	printf 'Usage: %s [-b|--(no-)base] [--(no-)selfupdate] [-p|--(no-)provision] [-m|--modules <arg>] [--lsrc] [--rcup] [--rcdn] [-h|--help]\n' "$0"
	printf '\t%s\n' "-b, --base, --no-base: Run base module (on by default)"
	printf '\t%s\n' "--selfupdate, --no-selfupdate: Update set-me-up (off by default)"
	printf '\t%s\n' "-p, --provision, --no-provision: Provision given modules (off by default)"
	printf '\t%s\n' "-m, --modules: Modules to provision (empty by default)"
	printf '\t%s\n' "--lsrc: List files that will be symlinked via 'rcm' into your home directory"
	printf '\t%s\n' "--rcup: Symlink files via 'rcm' into your home directory"
	printf '\t%s\n' "--rcdn: Remove files that were symlinked via 'rcup'"
	printf '\t%s\n' "-h, --help: Prints help"
}


# The parsing of the command-line
parse_commandline()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			# The base argurment doesn't accept a value,
			# we expect the --base or -b, so we watch for them.
			-b|--no-base|--base)
				_arg_base="on"
				test "${1:0:5}" = "--no-" && _arg_base="off"
				;;
			# We support getopts-style short arguments clustering,
			# so as -b doesn't accept value, other short options may be appended to it, so we watch for -b*.
			# After stripping the leading -b from the argument, we have to make sure
			# that the first character that follows coresponds to a short option.
			-b*)
				_arg_base="on"
				_next="${_key##-b}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-b" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option '--base' to see what's going on here - principle is the same.
			--no-selfupdate|--selfupdate)
				_arg_selfupdate="on"
				test "${1:0:5}" = "--no-" && _arg_selfupdate="off"
				;;
			# See the comment of option '--base' to see what's going on here - principle is the same.
			-p|--no-provision|--provision)
				_arg_provision="on"
				test "${1:0:5}" = "--no-" && _arg_provision="off"
				;;
			# See the comment of option '-b' to see what's going on here - principle is the same.
			-p*)
				_arg_provision="on"
				_next="${_key##-p}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-p" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# We support whitespace as a delimiter between option argument and its value.
			# Therefore, we expect the --modules or -m value.
			# so we watch for --modules and -m.
			# Since we know that we got the long or short option,
			# we just reach out for the next argument to get the value.
			-m|--modules)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_modules+=("$2")
				shift
				;;
			# We support the = as a delimiter between option argument and its value.
			# Therefore, we expect --modules=value, so we watch for --modules=*
			# For whatever we get, we strip '--modules=' using the ${var##--modules=} notation
			# to get the argument value
			--modules=*)
				_arg_modules+=("${_key##--modules=}")
				;;
			# We support getopts-style short arguments grouping,
			# so as -m accepts value, we allow it to be appended to it, so we watch for -m*
			# and we strip the leading -m from the argument string using the ${var##-m} notation.
			-m*)
				_arg_modules+=("${_key##-m}")
				;;
			# See the comment of option '--base' to see what's going on here - principle is the same.
			--lsrc)
				list_symlinks
				exit 0
				;;
			# See the comment of option '--base' to see what's going on here - principle is the same.
			--rcup)
				symlink
				exit 0
				;;
			# See the comment of option '--base' to see what's going on here - principle is the same.
			--rcdn)
				remove_symlinks
				exit 0
				;;
			# See the comment of option '--base' to see what's going on here - principle is the same.
			-h|--help)
				print_help
				exit 0
				;;
			# See the comment of option '-b' to see what's going on here - principle is the same.
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

provision_enabled() {
    [[ ${_arg_provision} == "on" ]]
}

export _arg_provision
export -f provision_enabled

provision_module() {
    # source base from installation directory.
    # this enables smu to work on first time installations.
    if [[ "${module}" == "base" ]]; then
        local -r path="${SMU_HOME_DIR}/.dotfiles/base"
    else
        local -r path="${module_path}/${1}"
    fi

    local -r script="${1}.sh"

    if [[ ! -e "${path}/${script}" ]]; then
        echo "${path}/${script} does not seem to exist, skipping."
        false
        return
    fi

    echo "Running ${path}/${script} module"

	printf "\n"

    (
        cd "${path}/" &&
        [[ -s ./before.sh ]] && source ./before.sh
        source "./${script}" &&
        [[ -s ./after.sh ]] && source ./after.sh
    )
}

main() {
	if [[ ${_arg_selfupdate} == "on" ]]; then
		if [[ -e "${module_path}"/install.sh ]]; then
			"${module_path}"/install.sh
		else
			echo -e "${module_path}/install.sh does not seem to exist.\nPlease run the 'base' module prior to executing a 'selfupdate'."
		fi

		! provision_enabled && exit 0
	fi

	if ! provision_enabled ; then
		_PRINT_HELP=yes die "Please provide the --provision switch to run set-me-up." 1
		exit 0
	fi

	read -r -p "set-me-up may overwrite existing files in your home directory. Are you sure? (y/n) " -n 1;
	echo "";
	[[ ! $REPLY =~ ^[Yy]$ ]] && exit 0

	modules=("${_arg_modules[@]}")

	# by default, run the base module as early as possible.
	if [[ ${_arg_base} == "on" ]]; then
		modules=("base" "${modules[@]}")
	fi

	# check if debianupdate is contained in module list and if so, queue it at the beginning.
	if [[ " ${modules[@]} " =~ " debianupdate " ]]; then
		modules=("debianupdate" "${modules[@]}")
	fi

	# list of executed modules, so we only run them once.
	done=()

	# run modules
	for module in "${modules[@]}"
	do
		if [[ ! " ${done[@]} " =~ " ${module} " ]]; then
			provision_module "${module}"
			done=("${module}" "${done[@]}")
		fi
	done

	printf "\n"

	echo "------------------------------"
	echo "Completed running set-me-up, restart your computer to ensure all updates take effect."
	echo "------------------------------"
}

main

# ] <-- needed because of Argbash
